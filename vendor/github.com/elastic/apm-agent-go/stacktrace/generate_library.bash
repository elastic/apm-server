#!/bin/bash

set -e

_PKGS=$(go list -f '{{printf "\t%q: true,\n" .ImportPath}}' "$@")

cat > library.go <<EOF
// Code generated by "go generate". DO NOT EDIT.

package stacktrace

import (
	"strings"

	"github.com/elastic/apm-agent-go/internal/radix"
)

var libraryPackages = radix.NewFromMap(map[string]interface{}{
$_PKGS
})

// RegisterLibraryPackage registers the given packages as being
// well-known library path prefixes. This must not be called
// concurrently with any other functions or methods in this
// package; it is expected to be used by init functions.
func RegisterLibraryPackage(pkg ...string) {
	for _, pkg := range pkg {
		libraryPackages.Insert(pkg, true)
	}
}

// RegisterApplicationPackage registers the given packages as being
// an application path. This must not be called concurrently with
// any other functions or methods in this package; it is expected
// to be used by init functions.
//
// It is not typically necessary to register application paths. If
// a package does not match a registered *library* package path
// prefix, then the path is considered an application path. This
// function exists for the unusual case that an application exists
// within a library (e.g. an example program).
func RegisterApplicationPackage(pkg ...string) {
	for _, pkg := range pkg {
		libraryPackages.Insert(pkg, false)
	}
}

// IsLibraryPackage reports whether or not the given package path is
// a well-known library path (stdlib or apm-agent-go).
func IsLibraryPackage(pkg string) bool {
	if strings.HasSuffix(pkg, "_test") {
		return false
	}
	prefix, v, ok := libraryPackages.LongestPrefix(pkg)
	if !ok || v == false {
		return false
	}
	return prefix == pkg || pkg[len(prefix)] == '/'
}
EOF

gofmt -w library.go
