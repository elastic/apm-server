// Licensed to Elasticsearch B.V. under one or more contributor
// license agreements. See the NOTICE file distributed with
// this work for additional information regarding copyright
// ownership. Elasticsearch B.V. licenses this file to you under
// the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

package main

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"

	"github.com/tidwall/gjson"
	"github.com/tidwall/sjson"

	"github.com/elastic/apm-server/model"
)

var streamMappings = map[string]string{
	"error_logs":       "logs-" + model.ErrorsDataset,
	"traces":           "traces-" + model.TracesDataset,
	"app_metrics":      "metrics-" + model.AppMetricsDataset,
	"internal_metrics": "metrics-" + model.InternalMetricsDataset,
	"profile_metrics":  "metrics-" + model.ProfilesDataset,
}

type PipelineDef struct {
	ID   string          `json:"id"`
	Body json.RawMessage `json:"body"`
}

func generatePipelines(version, dataStream string) error {
	pipelines, err := os.Open("ingest/pipeline/definition.json")
	if err != nil {
		return err
	}
	defer pipelines.Close()

	bytes, err := ioutil.ReadAll(pipelines)
	if err != nil {
		return err
	}
	var definitions []PipelineDef
	if err := json.Unmarshal(bytes, &definitions); err != nil {
		return err
	}

	if err := os.MkdirAll(pipelinesPath(version, dataStream), 0755); err != nil {
		return err
	}

	var apmPipelineBody json.RawMessage
	for _, definition := range definitions {
		if definition.ID == "apm" {
			apmPipelineBody = definition.Body
			continue
		}
		fName := filepath.Join(pipelinesPath(version, dataStream), definition.ID+".json")
		if err := writeFilePipelineJSON(fName, definition.Body); err != nil {
			return err
		}
	}

	pipelineNames := gjson.GetBytes(apmPipelineBody, "processors.#.pipeline.name")
	if !pipelineNames.Exists() {
		return errors.New("failed to locate pipeline processor names in 'apm' pipeline")
	}
	for i, pipelineNameResult := range pipelineNames.Array() {
		// Update name to match the one generated by Fleet when installs the pipelines.
		pipelineName := pipelineNameResult.Str
		pipelineName = fmt.Sprintf("%s-%s-%s", streamMappings[dataStream], version, pipelineName)
		out, err := sjson.SetBytes(apmPipelineBody, fmt.Sprintf("processors.%d.pipeline.name", i), pipelineName)
		if err != nil {
			return err
		}
		apmPipelineBody = out
	}
	fName := filepath.Join(pipelinesPath(version, dataStream), "default.json")
	return writeFilePipelineJSON(fName, apmPipelineBody)
}

func writeFilePipelineJSON(filename string, v []byte) error {
	f, err := os.OpenFile(filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
	if err != nil {
		return err
	}
	defer f.Close()

	var indented bytes.Buffer
	if err := json.Indent(&indented, v, "", "  "); err != nil {
		return err
	}
	_, err = indented.WriteTo(f)
	return err
}
