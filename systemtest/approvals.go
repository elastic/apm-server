// Licensed to Elasticsearch B.V. under one or more contributor
// license agreements. See the NOTICE file distributed with
// this work for additional information regarding copyright
// ownership. Elasticsearch B.V. licenses this file to you under
// the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

package systemtest

import (
	"fmt"
	"path/filepath"
	"sort"
	"testing"
	"time"

	"github.com/tidwall/gjson"

	"github.com/elastic/apm-server/approvaltest"
	"github.com/elastic/apm-server/systemtest/estest"
)

// ApproveEvents compares the _source of the search hits with the
// contents of the file in "systemtest/approvals/<name>.approved.json".
//
// Dynamic fields (@timestamp, observer.id, etc.) are replaced
// with a static string for comparison. Integration tests elsewhere
// use canned data to test fields that we do not cover here.
//
// If the events differ, then the test will fail.
func ApproveEvents(t testing.TB, name string, hits []estest.SearchHit, dynamic ...string) {
	t.Helper()

	// Fields generated by the server (e.g. observer.*)
	// agent which may change between tests.
	//
	// Ignore their values in comparisons, but compare
	// existence: either the field exists in both, or neither.
	approvalDynamic := []approvaltest.Dynamic{
		approvaltest.Dynamic{Name: "ecs.version"},
		approvaltest.Dynamic{Name: "event.ingested"},
		approvaltest.Dynamic{Name: "observer.ephemeral_id"},
		approvaltest.Dynamic{Name: "observer.hostname"},
		approvaltest.Dynamic{Name: "observer.id"},
		approvaltest.Dynamic{Name: "observer.version"},
	}
	for _, name := range dynamic {
		d := approvaltest.Dynamic{Name: name}
		if name == "@timestamp" {
			d.Check = func(val interface{}) bool {
				if val == nil {
					return true
				}
				parsedT, err := time.Parse("2006-01-02T15:04:05.000Z07:00", fmt.Sprintf("%v", val))
				if err != nil {
					t.Fatal(fmt.Errorf("parsing timestamp failed with %v", err))
				}
				return !parsedT.IsZero()
			}
		}
		approvalDynamic = append(approvalDynamic, d)
	}

	// Sort events for repeatable diffs.
	sort.Sort(apmEventSearchHits(hits))

	sources := make([][]byte, len(hits))
	for i, hit := range hits {
		sources[i] = hit.RawSource
	}
	approvaltest.ApproveEventDocs(t, filepath.Join("approvals", name), sources, approvalDynamic...)
}

var apmEventSortFields = []string{
	"processor.event",
	"trace.id",
	"transaction.id",
	"span.id",
	"error.id",
	"timeseries.instance",
	"span.destination.service.resource",
	"@timestamp", // last resort, order is generally guaranteed
}

type apmEventSearchHits []estest.SearchHit

func (hits apmEventSearchHits) Len() int {
	return len(hits)
}

func (hits apmEventSearchHits) Swap(i, j int) {
	hits[i], hits[j] = hits[j], hits[i]
}

func (hits apmEventSearchHits) Less(i, j int) bool {
	for _, field := range apmEventSortFields {
		ri := gjson.GetBytes(hits[i].RawSource, field)
		rj := gjson.GetBytes(hits[j].RawSource, field)
		if ri.Less(rj, true) {
			return true
		}
		if rj.Less(ri, true) {
			return false
		}
	}
	return false
}
