// Licensed to Elasticsearch B.V. under one or more contributor
// license agreements. See the NOTICE file distributed with
// this work for additional information regarding copyright
// ownership. Elasticsearch B.V. licenses this file to you under
// the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

package gencorpora

import (
	"bufio"
	"compress/gzip"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net"
	"net/http"
	"os"
	"path/filepath"
	"time"

	"github.com/elastic/go-elasticsearch/v8/esutil"
)

// CatBulkServer wraps http server and a listener to listen
// for ES requests on any available port
type CatBulkServer struct {
	listener net.Listener
	server   *http.Server
	Addr     string

	writer io.WriteCloser

	metaUpdateChan chan docsStat
	metaWriteDone  chan struct{}
}

// docsStat represents statistics of ES docs generated by a request
type docsStat struct {
	count int
	bytes int
}

// NewCatBulkServer returns a HTTP Server which can serve as a
// fake ES server writing the response of the bulk request to the
// provided writer. Writes to the provided writer must be thread safe.
func NewCatBulkServer() (*CatBulkServer, error) {
	listener, err := net.Listen("tcp", ":0")
	if err != nil {
		return nil, err
	}

	writer, err := getWriter(gencorporaConfig.CorporaPath)
	if err != nil {
		return nil, err
	}

	addr := listener.Addr().String()
	metaUpdateChan := make(chan docsStat)
	return &CatBulkServer{
		listener: listener,
		Addr:     addr,
		server: &http.Server{
			Addr:    addr,
			Handler: handleReq(metaUpdateChan, writer),
		},
		writer:         writer,
		metaUpdateChan: metaUpdateChan,
		metaWriteDone:  make(chan struct{}),
	}, nil
}

// Serve starts the fake ES server on a listener.
func (s *CatBulkServer) Serve() error {
	go func() {
		if err := s.metaWriter(); err != nil {
			log.Println("failed to write metadata", err)
		}
	}()

	if err := s.server.Serve(s.listener); err != http.ErrServerClosed {
		return err
	}
	return nil
}

// Stop initiates graceful shutdown the underlying HTTP server and writes
// generated corpus metadata on successful shutdown.
func (s *CatBulkServer) Stop() error {
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()
	defer s.writer.Close()

	if err := s.server.Shutdown(ctx); err != nil {
		return fmt.Errorf("failed to shutdown cat bulk server with error %v, no metadata written", err)
	}

	close(s.metaUpdateChan)
	<-s.metaWriteDone

	return nil
}

func (s *CatBulkServer) metaWriter() error {
	metadata := struct {
		SourceFile                 string `json:"source-file"`
		DocumentCount              int    `json:"document-count"`
		UncompressedBytes          int    `json:"uncompressed-bytes"`
		IncludedsActionAndMetadata bool   `json:"includes-action-and-meta-data"`
	}{
		SourceFile:                 gencorporaConfig.CorporaPath,
		IncludedsActionAndMetadata: true,
	}

	defer close(s.metaWriteDone)

	// update metadata as request is received by the server
	for stat := range s.metaUpdateChan {
		metadata.DocumentCount += stat.count
		metadata.UncompressedBytes += stat.bytes
	}

	// write metadata to a file
	metadataBytes, err := json.MarshalIndent(metadata, "", "  ")
	if err != nil {
		return err
	}

	writer, err := getWriter(gencorporaConfig.MetadataPath)
	defer writer.Close()

	if _, err := writer.Write(metadataBytes); err != nil {
		return err
	}

	return nil
}

func handleReq(metaUpdateChan chan docsStat, writer io.Writer) http.HandlerFunc {
	return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
		w.Header().Set("X-Elastic-Product", "Elasticsearch")
		switch req.Method {
		case http.MethodGet:
			w.WriteHeader(http.StatusOK)
			w.Write([]byte(`{"cluster_uuid": "cat_bulk"}`))
		case http.MethodPost:
			reader := req.Body
			defer req.Body.Close()

			if encoding := req.Header.Get("Content-Encoding"); encoding == "gzip" {
				var err error
				reader, err = gzip.NewReader(reader)
				if err != nil {
					log.Println("failed to read request body", err)
					w.WriteHeader(http.StatusBadRequest)
					return
				}
			}

			mockResp := esutil.BulkIndexerResponse{}
			scanner := bufio.NewScanner(reader)
			var stat docsStat
			for count := 0; scanner.Scan(); count++ {
				n, err := fmt.Fprintln(writer, scanner.Text())
				stat.bytes += n

				// create mock bulk response considering all request items
				// exist with action_and_metadata followed by source line
				if count%2 == 0 {
					respStatus := http.StatusOK
					if err != nil {
						respStatus = http.StatusInternalServerError
						stat.count++
					}

					item := map[string]esutil.BulkIndexerResponseItem{
						"action": {Status: respStatus},
					}
					mockResp.Items = append(mockResp.Items, item)
					stat.count++
				}
			}

			// Update metadata with the ES document statistics generated by this request
			metaUpdateChan <- stat

			resp, err := json.Marshal(mockResp)
			if err != nil {
				log.Println("failed to encode response to JSON", err)
				w.WriteHeader(http.StatusInternalServerError)
				return
			}
			w.WriteHeader(http.StatusOK)
			w.Write(resp)
		default:
			w.WriteHeader(http.StatusNotFound)
		}
	})
}

func getWriter(path string) (io.WriteCloser, error) {
	if path == "" {
		return os.Stdout, nil
	}
	return os.Create(filepath.Join(path))
}
