[![Integration Server Test](https://github.com/elastic/apm-server/actions/workflows/integration-server-test.yml/badge.svg)](https://github.com/elastic/apm-server/actions/workflows/integration-server-test.yml)

# Integration Server Test

The integration server test checks that APM Server in Elastic Cloud Hosted works as expected after version upgrades.

## Code Details

The following is a simplified directory structure of integration server test.
```
- integrationservertest/
   |- infra/
   |- internal/
   |- scripts/
   |- main_test.go
   |- standalone_test.go
   |- upgrade_test.go
```

The `internal/` directory contains helper packages used in the tests, e.g. Elasticsearch, Kibana client wrapper etc.

The `infra/` directory contains infrastructure related code. In our case, we use Terraform for deploying the stack in Elastic Cloud.
The Terraform files are located in `infra/terraform`, and are copied into `tf-<test_name>/` e.g. `tf-TestUpgrade_8_19_to_9_0/`, at the start of each test (since Terraform saves state in the directory it is initialized in).

The `scripts/` directory contains scripts that are used by the integration server test workflow.
The rest are test files / utility functions for the tests.

### Upgrade Tests

The upgrade tests reside in `upgrade_test.go`.

These tests take an `upgrade-path` argument that represents a list of versions for the upgrade test.
The test will create a deployment with the first version, perform ingestion and check that everything is expected.
Then, it will consecutively upgrade to the next version, perform ingestion and check again.
For example, if we provide an `upgrade-path` of `8.17.4 -> 8.18.0 -> 8.19.0`, a deployment will be created in `8.17.4`, upgraded to `8.18.0` and then to `8.19.0`.

We provide the `upgrade-path` argument through GitHub workflow matrix, see `integration-server-test.yml`.
Configuration for the upgrade test can be found in `upgrade-config.yaml`.

#### Upgrade Path Generation

The upgrade path is generated by the script in `scripts/genpath`, and it works by first retrieving active versions from Elastic APIs.
Once the active versions are retrieved, each version is paired with a random upgradable previous version (a minimum version can be specified).
For example, if the active versions are `8.19`, `9.0` and `9.1`, with a minimum previous version of `8.17`, the script could have pairs like so:
- `8.17 -> 8.19`
- `8.18 -> 9.0`
- `8.19 -> 9.1`

Then, the script tries to merge these pairs such that they form a long upgrade chain.
In the example above, since `8.17` upgrades to `8.19` and `8.19` upgrades to `9.1`, we can simply continue upgrading instead of creating a new deployment.
Hence, we are left with the following to be used as upgrade paths:
- `8.17 -> 8.19 -> 9.1`
- `8.18 -> 9.0`

We use randomization to pick the upgrades since trying to upgrade every version will take up too much time and resources.
With this approach, there is a high certainty that over the course of weeks, all possible upgrade paths will have been tested.
That said, in order to avoid RNG not testing some important upgrade paths, the latest versions of each major (in our example, it would be `8.19` and `9.1`) will have 1 major upgrade and 1 minor upgrade forcefully added (while respecting minimum previous version).
Our example pairs above would instead become:
- `8.17 -> 8.19`
- `8.18 -> 8.19`
- `8.18 -> 9.0`
- `8.19 -> 9.1`
- `9.0 -> 9.1`

Which will yield the following upgrade paths:
- `8.17 -> 8.19 -> 9.1`
- `8.18 -> 8.19`
- `8.18 -> 9.0 -> 9.1`

### Standalone-to-Managed Tests

The standalone-to-managed tests reside in `standalone_test.go`

These tests test the migration from standalone APM Server to Fleet-managed. Currently, the tests include:
- 7.x standalone -> 8.x standalone -> 8.x managed -> 9.x managed
- 7.x standalone -> 8.x standalone -> 9.x standalone -> 9.x managed
- 7.x standalone -> 7.x managed -> 8.x managed -> 9.x managed

## Running the Tests

To run the tests, you will first need to set the `EC_API_KEY` environment variable, which can be obtained by following [this guide](https://www.elastic.co/guide/en/cloud/current/ec-api-authentication.html).

### Upgrade Tests

For upgrade tests:
```sh
go test -run=TestUpgrade_UpgradePath -v -timeout=60m -cleanup-on-failure=false -target="pro" -upgrade-path="<some_upgrade_path>" ./
```

### Standalone-to-Managed Tests

For standalone tests:
```sh
go test -run=TestStandaloneManaged -v -timeout=60m -cleanup-on-failure=false -target="pro" ./
```

## Debugging the Tests

If you get some errors after running the test, you can try heading to the [Elastic Cloud console](https://cloud.elastic.co/home) in order to access the Kibana instance. 
From there, you can use Dev Tools to check the data streams etc.

Note: If the tests failed due to deployment or in CI, you may need to access the Elastic Cloud admin console instead to check the errors.

## Testing Custom APM Server Changes

In some cases, you may want to run the integration server test against a custom image of APM Server. 
To do so, first make the change in the APM Server code and upload the custom built Docker image by running from root directory:
```sh
make docker-override-committed-version
```

This will build the APM Server Docker image and upload it, while generating a `docker_image.auto.tfvars` file in `../testing/benchmark`.
Then, copy `docker-image-override.yaml.example` and rename it to `docker-image-override.yaml` and change the version that you want to override at the top-level.
Simply copy the field contents of `docker_image.auto.tfvars` to the respective field equivalents in `docker-image-override.yaml` as shown in the example.

```yaml
# The version that you want to override.
9.2.0-SNAPSHOT: 
  elasticsearch:
    docker: "docker.elastic.co/cloud-release/elasticsearch-cloud-ess"
    image-tag: "9.2.0-19106e12-SNAPSHOT"
  kibana:
    docker: "docker.elastic.co/cloud-release/kibana-cloud"
    image-tag: "9.2.0-19106e12-SNAPSHOT"
  apm:
    docker: "docker.elastic.co/observability-ci/elastic-agent"
    # The APM Server image tag that you want to use as override.
    image-tag: "9.2.0-19106e12-SNAPSHOT-ericyap-1757409444"
```

In the example above, we want to override the Docker image only if the version is `9.2.0-SNAPSHOT` and we want to override the APM Server Docker image tag with a custom built one: `9.2.0-19106e12-SNAPSHOT-ericyap-1757409444`.
The rest are simply copied from `docker_image.auto.tfvars` as is.
Note that you can specify multiple versions to override at the top-level.

Finally, run the test as per usual and the override will happen automatically, e.g.
```sh
go test -run="TestUpgrade/.*/Default" -v -timeout=60m -cleanup-on-failure=true -target="pro" -upgrade-path="9.1.4-SNAPSHOT -> 9.2.0-SNAPSHOT" ./
```
