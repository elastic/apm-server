---
name: create-test-plan-patch

on:
  workflow_dispatch:
    inputs:
      upcoming_release:
        description: 'Upcoming release version (e.g., 9.2.6)'
        required: true
        type: string

permissions:
  contents: read
  issues: write

jobs:
  analyze-commits:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          fetch-depth: 0  # Fetch all history for all branches and tags

      - name: Infer branch and previous tag
        id: infer-versions
        run: |
          # Parse input version (expected format: 9.2.6)
          UPCOMING="${{ inputs.upcoming_release }}"
          
          # Extract version components (e.g., 9.2.6 -> 9, 2, 6)
          if [[ "$UPCOMING" =~ ^([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
            MAJOR="${BASH_REMATCH[1]}"
            MINOR="${BASH_REMATCH[2]}"
            PATCH="${BASH_REMATCH[3]}"
          else
            echo "Error: Invalid version format. Expected format: 9.2.6"
            exit 1
          fi
          
          # Check if patch version is 0
          if [ "$PATCH" -eq 0 ]; then
            echo "Error: Cannot infer previous tag for x.y.0 releases. Patch version must be >= 1"
            exit 1
          fi
          
          # Infer branch (e.g., 9.2)
          BRANCH="$MAJOR.$MINOR"
          echo "release_branch=$BRANCH" >> $GITHUB_OUTPUT
          echo "upcoming_release=v$UPCOMING" >> $GITHUB_OUTPUT
          
          # Calculate previous patch version (e.g., 9.2.6 -> 9.2.5)
          PREVIOUS_PATCH=$((PATCH - 1))
          PREVIOUS_TAG="v${MAJOR}.${MINOR}.${PREVIOUS_PATCH}"
          
          echo "Finding previous tag: $PREVIOUS_TAG..."
          
          # Verify the previous tag exists
          if ! git rev-parse "$PREVIOUS_TAG" >/dev/null 2>&1; then
            echo "Error: Previous tag $PREVIOUS_TAG does not exist in the repository"
            exit 1
          fi
          
          echo "previous_tag=$PREVIOUS_TAG" >> $GITHUB_OUTPUT
          
          echo "Upcoming release: v$UPCOMING"
          echo "Release branch: $BRANCH"
          echo "Previous tag: $PREVIOUS_TAG"

      - name: Get commits between tag and branch
        id: get-commits
        run: |
          # Get the list of commits between the tag and branch
          echo "Getting commits between ${{ steps.infer-versions.outputs.previous_tag }} and origin/${{ steps.infer-versions.outputs.release_branch }}"
          
          # Create commits file with hash, author, date, and message
          git log --pretty=format:"%H|%an|%ad|%s" --date=short ${{ steps.infer-versions.outputs.previous_tag }}..origin/${{ steps.infer-versions.outputs.release_branch }} > commits.txt
          
          # Count commits
          COMMIT_COUNT=$(wc -l < commits.txt)
          echo "commit_count=$COMMIT_COUNT" >> $GITHUB_OUTPUT
          
          # Create a detailed commit log
          git log --pretty=format:"- %H: %s (by %an on %ad)" --date=short ${{ steps.infer-versions.outputs.previous_tag }}..origin/${{ steps.infer-versions.outputs.release_branch }} > commits_detailed.txt
          
          echo "Found $COMMIT_COUNT commits to analyze"
          cat commits_detailed.txt

      - name: Generate go.mod changes summary
        id: go-mod-changes
        run: |
          # Check for go.mod changes
          if git diff ${{ steps.infer-versions.outputs.previous_tag }}..origin/${{ steps.infer-versions.outputs.release_branch }} -- go.mod > go_mod_diff.txt; then
            if [ -s go_mod_diff.txt ]; then
              echo "go_mod_changed=true" >> $GITHUB_OUTPUT
              echo "Go.mod changes detected:"
              
              # Extract dependency changes
              echo "## Dependency Changes in go.mod" > dependency_summary.txt
              echo "" >> dependency_summary.txt
              
              # Look for apm-aggregation changes
              if grep -q "apm-aggregation" go_mod_diff.txt; then
                echo "### apm-aggregation" >> dependency_summary.txt
                grep "apm-aggregation" go_mod_diff.txt | sed 's/^[+-]//' >> dependency_summary.txt
                echo "" >> dependency_summary.txt
              fi
              
              # Look for go-docappender changes
              if grep -q "go-docappender" go_mod_diff.txt; then
                echo "### go-docappender" >> dependency_summary.txt
                grep "go-docappender" go_mod_diff.txt | sed 's/^[+-]//' >> dependency_summary.txt
                echo "" >> dependency_summary.txt
              fi
              
              # Look for apm-data changes
              if grep -q "apm-data" go_mod_diff.txt; then
                echo "### apm-data" >> dependency_summary.txt
                grep "apm-data" go_mod_diff.txt | sed 's/^[+-]//' >> dependency_summary.txt
                echo "" >> dependency_summary.txt
              fi
              
              cat dependency_summary.txt
            else
              echo "go_mod_changed=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "go_mod_changed=false" >> $GITHUB_OUTPUT
          fi

      - name: Create commit analysis summary
        run: |
          cat > commit_analysis.md <<EOF
          # Commit Analysis: ${{ steps.infer-versions.outputs.previous_tag }} to ${{ steps.infer-versions.outputs.release_branch }}

          **Analysis Date:** $(date +"%Y-%m-%d %H:%M:%S UTC")  
          **Previous Tag:** ${{ steps.infer-versions.outputs.previous_tag }}  
          **Release Branch:** ${{ steps.infer-versions.outputs.release_branch }}  
          **Upcoming Release:** ${{ steps.infer-versions.outputs.upcoming_release }}  
          **Total Commits:** ${{ steps.get-commits.outputs.commit_count }}

          ---

          ## Overview

          This analysis categorizes commits between release tag \`${{ steps.infer-versions.outputs.previous_tag }}\` and branch \`${{ steps.infer-versions.outputs.release_branch }}\` for the upcoming release \`${{ steps.infer-versions.outputs.upcoming_release }}\`.

          EOF
          
          # Add dependency summary if available
          if [ -f dependency_summary.txt ]; then
            cat dependency_summary.txt >> commit_analysis.md
            echo "" >> commit_analysis.md
          fi
          
          echo "## Detailed Commit List" >> commit_analysis.md
          echo "" >> commit_analysis.md
          
          # Parse commits and categorize them
          while IFS='|' read -r hash author date message; do
            # Categorize based on commit message for dependency bumps only
            category="other"
            
            if echo "$message" | grep -qi "apm-aggregation\|elastic/apm-aggregation"; then
              category="apm-aggregation"
            elif echo "$message" | grep -qi "go-docappender\|elastic/go-docappender"; then
              category="go-docappender"
            elif echo "$message" | grep -qi "apm-data\|elastic/apm-data"; then
              category="apm-data"
            fi
            
            echo "[$category] ${hash:0:8}: $message (by $author on $date)" >> categorized_commits.txt
          done < commits.txt
          
          # Group commits by category - simple listing without interpretation
          for category in "apm-aggregation" "go-docappender" "apm-data" "other"; do
            case $category in
              apm-aggregation) title="### APM Aggregation Changes" ;;
              go-docappender) title="### Go DocAppender Changes" ;;
              apm-data) title="### APM Data Changes" ;;
              other) title="### Other Changes" ;;
            esac
            
            if grep -q "^\[$category\]" categorized_commits.txt; then
              echo "" >> commit_analysis.md
              echo "$title" >> commit_analysis.md
              echo "" >> commit_analysis.md
              grep "^\[$category\]" categorized_commits.txt | sed 's/^\['"$category"'\] /- /' >> commit_analysis.md
            fi
          done
          
          echo "" >> commit_analysis.md
          echo "---" >> commit_analysis.md
          echo "" >> commit_analysis.md
          echo "_Analysis generated by GitHub Actions workflow_" >> commit_analysis.md

      - name: Upload analysis artifacts
        uses: actions/upload-artifact@v4
        with:
          name: commit-analysis-${{ steps.infer-versions.outputs.upcoming_release }}-to-${{ steps.infer-versions.outputs.release_branch }}
          path: |
            commit_analysis.md
            commits.txt
            commits_detailed.txt
            go_mod_diff.txt
            dependency_summary.txt
            categorized_commits.txt
          retention-days: 90

      - name: Display analysis summary
        run: |
          echo "# Commit Analysis Summary"
          echo ""
          cat commit_analysis.md
          echo ""
          echo "---"
          echo "Full analysis has been uploaded as an artifact."

      - name: Get dependency version changes
        id: dep-versions
        run: |
          # Extract version changes for key dependencies
          echo "Extracting dependency versions..."
          
          # Get old versions from the tag
          git show ${{ steps.infer-versions.outputs.previous_tag }}:go.mod > go.mod.old
          
          # Get new versions from the branch
          git show origin/${{ steps.infer-versions.outputs.release_branch }}:go.mod > go.mod.new
          
          # Extract apm-aggregation versions
          OLD_APM_AGG=$(grep "elastic/apm-aggregation" go.mod.old | awk '{print $2}' || echo "unknown")
          NEW_APM_AGG=$(grep "elastic/apm-aggregation" go.mod.new | awk '{print $2}' || echo "unknown")
          echo "apm_agg_old=$OLD_APM_AGG" >> $GITHUB_OUTPUT
          echo "apm_agg_new=$NEW_APM_AGG" >> $GITHUB_OUTPUT
          
          # Extract go-docappender versions
          OLD_DOCAPPENDER=$(grep "elastic/go-docappender" go.mod.old | awk '{print $3}' || echo "unknown")
          NEW_DOCAPPENDER=$(grep "elastic/go-docappender" go.mod.new | awk '{print $3}' || echo "unknown")
          echo "docappender_old=$OLD_DOCAPPENDER" >> $GITHUB_OUTPUT
          echo "docappender_new=$NEW_DOCAPPENDER" >> $GITHUB_OUTPUT
          
          # Extract apm-data versions
          OLD_APM_DATA=$(grep "elastic/apm-data" go.mod.old | awk '{print $2}' || echo "unknown")
          NEW_APM_DATA=$(grep "elastic/apm-data" go.mod.new | awk '{print $2}' || echo "unknown")
          echo "apm_data_old=$OLD_APM_DATA" >> $GITHUB_OUTPUT
          echo "apm_data_new=$NEW_APM_DATA" >> $GITHUB_OUTPUT
          
          echo "apm-aggregation: $OLD_APM_AGG â†’ $NEW_APM_AGG"
          echo "go-docappender: $OLD_DOCAPPENDER â†’ $NEW_DOCAPPENDER"
          echo "apm-data: $OLD_APM_DATA â†’ $NEW_APM_DATA"

      - name: Create test plan issue body
        id: create-test-plan
        run: |
          # Create the test plan issue body
          cat > test_plan_issue.md <<'TESTPLAN'
          # Manual Test Plan
          
          - When picking up a test case, please add your name to this overview beforehand and tick the checkbox when finished.
          - Testing can be started when the first build candidate (BC) is available in the CFT region.
          - For each repository, update the compare version range to get the list of commits to review.
          
          ## ES apm-data plugin
          
          <!-- Add any issues / PRs which were worked on during the milestone release https://github.com/elastic/elasticsearch/tree/main/x-pack/plugin/apm-data-->
          
          ## apm-aggregation
          
          TESTPLAN
          
          # Add apm-aggregation section
          if [ "${{ steps.dep-versions.outputs.apm_agg_old }}" != "${{ steps.dep-versions.outputs.apm_agg_new }}" ]; then
            cat >> test_plan_issue.md <<EOF
          
          List of changes: https://github.com/elastic/apm-aggregation/compare/${{ steps.dep-versions.outputs.apm_agg_old }}...${{ steps.dep-versions.outputs.apm_agg_new }}
          
          EOF
          else
            echo "" >> test_plan_issue.md
            echo "No version change detected." >> test_plan_issue.md
            echo "" >> test_plan_issue.md
          fi
          
          # Add apm-aggregation commits if any (even if version didn't change)
          if grep -q "^\[apm-aggregation\]" categorized_commits.txt; then
            grep "^\[apm-aggregation\]" categorized_commits.txt | sed 's/^\[apm-aggregation\] /- /' >> test_plan_issue.md
          fi
          
          # Add go-docappender section
          cat >> test_plan_issue.md <<'TESTPLAN'
          
          ## go-docappender
          
          TESTPLAN
          
          if [ "${{ steps.dep-versions.outputs.docappender_old }}" != "${{ steps.dep-versions.outputs.docappender_new }}" ]; then
            cat >> test_plan_issue.md <<EOF
          
          List of changes: https://github.com/elastic/go-docappender/compare/${{ steps.dep-versions.outputs.docappender_old }}...${{ steps.dep-versions.outputs.docappender_new }}
          
          EOF
          else
            echo "" >> test_plan_issue.md
            echo "No version change detected." >> test_plan_issue.md
            echo "" >> test_plan_issue.md
          fi
          
          # Add go-docappender commits if any (even if version didn't change)
          if grep -q "^\[go-docappender\]" categorized_commits.txt; then
            grep "^\[go-docappender\]" categorized_commits.txt | sed 's/^\[go-docappender\] /- /' >> test_plan_issue.md
          fi
          
          # Add apm-data section
          cat >> test_plan_issue.md <<'TESTPLAN'
          
          ## apm-data
          
          TESTPLAN
          
          if [ "${{ steps.dep-versions.outputs.apm_data_old }}" != "${{ steps.dep-versions.outputs.apm_data_new }}" ]; then
            cat >> test_plan_issue.md <<EOF
          
          List of changes: https://github.com/elastic/apm-data/compare/${{ steps.dep-versions.outputs.apm_data_old }}...${{ steps.dep-versions.outputs.apm_data_new }}
          
          EOF
          else
            echo "" >> test_plan_issue.md
            echo "No version change detected." >> test_plan_issue.md
            echo "" >> test_plan_issue.md
          fi
          
          # Add apm-data commits if any (even if version didn't change)
          if grep -q "^\[apm-data\]" categorized_commits.txt; then
            grep "^\[apm-data\]" categorized_commits.txt | sed 's/^\[apm-data\] /- /' >> test_plan_issue.md
          fi
          
          # Add apm-server section
          cat >> test_plan_issue.md <<EOF
          
          ## apm-server
          
          List of changes: https://github.com/elastic/apm-server/compare/${{ steps.infer-versions.outputs.previous_tag }}...${{ steps.infer-versions.outputs.release_branch }}
          
          EOF
          
          # Process other commits - split into dependency updates and actual changes
          if grep -q "^\[other\]" categorized_commits.txt; then
            grep "^\[other\]" categorized_commits.txt > other_commits.txt
            
            # Identify dependency updates using common patterns from repo history
            # Patterns: build(deps):, [updatecli], updatecli(...)
            grep "^\[other\]" categorized_commits.txt | grep -iE "build\(deps\)|^\[other\] [a-f0-9]+: \[updatecli\]|^\[other\] [a-f0-9]+: updatecli\(" > dep_commits.txt || touch dep_commits.txt
            
            # Group dependency-related commits by type
            dep_found=false
            
            # GitHub Actions dependencies
            if grep -qi "github-actions\|github\.com/actions" dep_commits.txt; then
              if [ "$dep_found" = false ]; then
                echo "" >> test_plan_issue.md
                echo "### Dependency updates" >> test_plan_issue.md
                echo "" >> test_plan_issue.md
                dep_found=true
              fi
              echo "#### GitHub Actions" >> test_plan_issue.md
              echo "" >> test_plan_issue.md
              grep -i "github-actions\|github\.com/actions" dep_commits.txt | sed 's/^\[other\] /- /' >> test_plan_issue.md
              echo "" >> test_plan_issue.md
            fi
            
            # Golang version bumps
            if grep -qi "bump golang\|golang version\|go version" dep_commits.txt; then
              if [ "$dep_found" = false ]; then
                echo "" >> test_plan_issue.md
                echo "### Dependency updates" >> test_plan_issue.md
                echo "" >> test_plan_issue.md
                dep_found=true
              fi
              echo "#### Golang" >> test_plan_issue.md
              echo "" >> test_plan_issue.md
              grep -i "bump golang\|golang version\|go version" dep_commits.txt | sed 's/^\[other\] /- /' >> test_plan_issue.md
              echo "" >> test_plan_issue.md
            fi
            
            # Elastic stack bumps
            if grep -qi "elastic stack\|update to elastic/beats" dep_commits.txt || grep -qi "\[updatecli\].*beats" dep_commits.txt; then
              if [ "$dep_found" = false ]; then
                echo "" >> test_plan_issue.md
                echo "### Dependency updates" >> test_plan_issue.md
                echo "" >> test_plan_issue.md
                dep_found=true
              fi
              echo "#### Elastic stack" >> test_plan_issue.md
              echo "" >> test_plan_issue.md
              grep -i "elastic stack\|update to elastic/beats\|\[updatecli\].*beats" dep_commits.txt | sed 's/^\[other\] /- /' >> test_plan_issue.md
              echo "" >> test_plan_issue.md
            fi
            
            # OTEL group dependencies
            if grep -qi "otel group" dep_commits.txt; then
              if [ "$dep_found" = false ]; then
                echo "" >> test_plan_issue.md
                echo "### Dependency updates" >> test_plan_issue.md
                echo "" >> test_plan_issue.md
                dep_found=true
              fi
              echo "#### OpenTelemetry" >> test_plan_issue.md
              echo "" >> test_plan_issue.md
              grep -i "otel group" dep_commits.txt | sed 's/^\[other\] /- /' >> test_plan_issue.md
              echo "" >> test_plan_issue.md
            fi
            
            # Other build(deps) commits not yet categorized
            if [ -s dep_commits.txt ]; then
              # Get commits from dep_commits.txt that haven't been matched yet
              UNMATCHED=$(grep -v -i "github-actions\|github\.com/actions\|bump golang\|golang version\|go version\|elastic stack\|update to elastic/beats\|\[updatecli\].*beats\|otel group" dep_commits.txt || true)
              if [ -n "$UNMATCHED" ]; then
                if [ "$dep_found" = false ]; then
                  echo "" >> test_plan_issue.md
                  echo "### Dependency updates" >> test_plan_issue.md
                  echo "" >> test_plan_issue.md
                  dep_found=true
                fi
                echo "#### Other dependencies" >> test_plan_issue.md
                echo "" >> test_plan_issue.md
                echo "$UNMATCHED" | sed 's/^\[other\] /- /' >> test_plan_issue.md
                echo "" >> test_plan_issue.md
              fi
            fi
            
            # Function changes - everything that's not a dependency update
            # Exclude commits that match dependency patterns
            FUNC_CHANGES=$(grep "^\[other\]" categorized_commits.txt | grep -viE "build\(deps\)|^\[other\] [a-f0-9]+: \[updatecli\]|^\[other\] [a-f0-9]+: updatecli\(" || true)
            if [ -n "$FUNC_CHANGES" ]; then
              echo "### Function changes" >> test_plan_issue.md
              echo "" >> test_plan_issue.md
              echo "$FUNC_CHANGES" | sed 's/^\[other\] /- /' >> test_plan_issue.md
            fi
          fi
          
          # Add test cases section
          VERSION_NUM=$(echo "${{ steps.infer-versions.outputs.release_branch }}" | tr -d '.')
          cat >> test_plan_issue.md <<EOF
          
          ## Test cases from the GitHub board
          
          Label the relevant ${{ steps.infer-versions.outputs.release_branch }} Issues / PRs with the \`test-plan\` label: https://github.com/elastic/apm-server/issues?page=1&q=-label%3Atest-plan+label%3Av${{ steps.infer-versions.outputs.release_branch }}.0+-label%3Atest-plan-ok
          
          [apm-server ${{ steps.infer-versions.outputs.release_branch }} test-plan](https://github.com/elastic/apm-server/issues?q=is%3Aissue+label%3Atest-plan+-label%3Atest-plan-ok+is%3Aclosed+label%3Av${{ steps.infer-versions.outputs.release_branch }}.0)
          
          Add yourself as _assignee_ on the PR before you start testing.
          
          ---
          
          _This test plan was automatically generated by the [create-test-plan-patch workflow](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})_
          EOF
          
          echo "Test plan issue body created!"
          cat test_plan_issue.md

      - name: Create GitHub issue
        id: create-issue
        run: |
          # Extract version number from upcoming release (remove 'v' prefix)
          VERSION="${{ steps.infer-versions.outputs.upcoming_release }}"
          VERSION="${VERSION#v}"
          
          # Create the issue
          ISSUE_URL=$(gh issue create \
            --title "$VERSION Test Plan" \
            --body-file test_plan_issue.md \
            --label "test-plan")
          
          echo "issue_url=$ISSUE_URL" >> $GITHUB_OUTPUT
          echo "Created test plan issue: $ISSUE_URL"
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Create summary
        run: |
          echo "# Test Plan Issue Created! ðŸŽ‰" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Issue URL:** ${{ steps.create-issue.outputs.issue_url }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Upcoming Release:** ${{ steps.infer-versions.outputs.upcoming_release }}" >> $GITHUB_STEP_SUMMARY
          echo "**Release Branch:** ${{ steps.infer-versions.outputs.release_branch }}" >> $GITHUB_STEP_SUMMARY
          echo "**Previous Tag:** ${{ steps.infer-versions.outputs.previous_tag }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Analyzed **${{ steps.get-commits.outputs.commit_count }}** commits between \`${{ steps.infer-versions.outputs.previous_tag }}\` and \`${{ steps.infer-versions.outputs.release_branch }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Dependency Versions" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Dependency | Old Version | New Version |" >> $GITHUB_STEP_SUMMARY
          echo "|------------|-------------|-------------|" >> $GITHUB_STEP_SUMMARY
          echo "| apm-aggregation | \`${{ steps.dep-versions.outputs.apm_agg_old }}\` | \`${{ steps.dep-versions.outputs.apm_agg_new }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| go-docappender | \`${{ steps.dep-versions.outputs.docappender_old }}\` | \`${{ steps.dep-versions.outputs.docappender_new }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| apm-data | \`${{ steps.dep-versions.outputs.apm_data_old }}\` | \`${{ steps.dep-versions.outputs.apm_data_new }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Quick Stats" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Category | Count |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          
          for category in "apm-aggregation" "go-docappender" "apm-data" "other"; do
            count=$(grep -c "^\[$category\]" categorized_commits.txt || echo "0")
            case $category in
              apm-aggregation) label="APM Aggregation" ;;
              go-docappender) label="Go DocAppender" ;;
              apm-data) label="APM Data" ;;
              other) label="Other" ;;
            esac
            echo "| $label | $count |" >> $GITHUB_STEP_SUMMARY
          done
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "1. Review the test plan issue: ${{ steps.create-issue.outputs.issue_url }}" >> $GITHUB_STEP_SUMMARY
          echo "2. Label relevant PRs/issues with \`test-plan\`" >> $GITHUB_STEP_SUMMARY
          echo "3. Assign team members to test cases" >> $GITHUB_STEP_SUMMARY
          echo "4. Start testing when the first build candidate (BC) is available" >> $GITHUB_STEP_SUMMARY
